/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//   Generated using Swaggie (https://github.com/yhnavein/swaggie)
//   Please avoid doing any manual changes in this file
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
// deno-lint-ignore-file

import { Observable, throwError as _observableThrow, of as _observableOf } from "rxjs";
import { Injectable, Inject, Optional, InjectionToken } from "@angular/core";
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from "@angular/common/http";

export const API_BASE_URL = new InjectionToken<string>("API_BASE_URL");

abstract class BaseService {
  private httpClient: HttpClient;
  private baseUrl: string;

  constructor(
    @Inject(HttpClient) httpClient: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.httpClient = httpClient;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  protected $get<T>(url: string, options?: any): Observable<T> {
    return this.httpClient
      .get<T>(this.baseUrl + url, options)
      .pipe((response: any) => response);
  }

  protected $getAll<T>(url: string, options?: any): Observable<T[]> {
    return this.httpClient
      .get<T[]>(this.baseUrl + url, options)
      .pipe((response: any) => response);
  }

  protected $delete<T>(url: string, options?: any): Observable<T> {
    return this.httpClient
      .delete(this.baseUrl + url, options)
      .pipe((response: any) => response);
  }

  protected $post(url: string, data: any, options?: any): Observable<any> {
    return this.httpClient
      .post(this.baseUrl + url, data, options)
      .pipe((response: any) => response);
  }

  protected $patch<T>(url: string, data: any, options?: any): Observable<T> {
    return this.httpClient
      .patch(this.baseUrl + url, data, options)
      .pipe((response: any) => response);
  }

  protected $put(url: string, data: any, options?: any): Observable<any> {
    return this.httpClient
      .put(this.baseUrl + url, data, options)
      .pipe((response: any) => response);
  }
}

@Injectable({
  providedIn: 'root'
})
export class petService extends BaseService {
  constructor(
    @Inject(HttpClient) httpClient: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    super(httpClient, baseUrl);
  }

  /**
   * @param body  
   * @return Success
   */
  addPet(
    body: Pet,
    config?: any
  ): Observable<unknown> {
    let url = '/pet?';

    return this.$post(
      url,
      body,
      config
    );
  }

/**
   * @param apiKey (optional) (API name: api_key)
   * @param petId  
   * @return Success
   */
  deletePet(
    apiKey: string | null | undefined,
    petId: number,
    config?: any
  ): Observable<unknown> {
    let url = '/pet/{petId}?';
    url = url.replace('{petId}', encodeURIComponent("" + petId));

    return this.$delete(
      url,
      config
    );
  }

/**
   * @param status  
   * @return Success
   */
  findPetsByStatus(
    status: ('available'|'pending'|'sold')[],
    config?: any
  ): Observable<Pet[]> {
    let url = '/pet/findByStatus?';
    if (status !== undefined) {
      status.forEach(item => { url += 'status=' + encodeURIComponent("" + item) + "&"; });
    }
  
    return this.$get(
      url,
      config
    );
  }

/**
   * @param tags  
   * @return Success
   */
  findPetsByTags(
    tags: string[],
    config?: any
  ): Observable<Pet[]> {
    let url = '/pet/findByTags?';
    if (tags !== undefined) {
      tags.forEach(item => { url += 'tags=' + encodeURIComponent("" + item) + "&"; });
    }
  
    return this.$get(
      url,
      config
    );
  }

/**
   * @param petId  
   * @return Success
   */
  getPetById(
    petId: number,
    config?: any
  ): Observable<Pet> {
    let url = '/pet/{petId}?';
    url = url.replace('{petId}', encodeURIComponent("" + petId));

    return this.$get(
      url,
      config
    );
  }

/**
   * @param body  
   * @return Success
   */
  updatePet(
    body: Pet,
    config?: any
  ): Observable<unknown> {
    let url = '/pet?';

    return this.$put(
      url,
      body,
      config
    );
  }

/**
   * @param petId  
   * @param name (optional) 
   * @param status (optional) 
   * @return Success
   */
  updatePetWithForm(
    petId: number,
    name: string | null | undefined,
    status: string | null | undefined,
    config?: any
  ): Observable<unknown> {
    let url = '/pet/{petId}?';
    url = url.replace('{petId}', encodeURIComponent("" + petId));
    const formDataBody = new FormData();
    if (!!name) {
      formDataBody.append("name", name);
    }
    if (!!status) {
      formDataBody.append("status", status);
    }

    return this.$post(
      url,
      formDataBody,
      config
    );
  }

/**
   * @param petId  
   * @param additionalMetadata (optional) 
   * @param file (optional) 
   * @return Success
   */
  uploadFile(
    petId: number,
    additionalMetadata: string | null | undefined,
    file: File | null | undefined,
    config?: any
  ): Observable<ApiResponse> {
    let url = '/pet/{petId}/uploadImage?';
    url = url.replace('{petId}', encodeURIComponent("" + petId));
    const formDataBody = new FormData();
    if (!!additionalMetadata) {
      formDataBody.append("additionalMetadata", additionalMetadata);
    }
    if (!!file) {
      formDataBody.append("file", file);
    }

    return this.$post(
      url,
      formDataBody,
      config
    );
  }

}

@Injectable({
  providedIn: 'root'
})
export class storeService extends BaseService {
  constructor(
    @Inject(HttpClient) httpClient: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    super(httpClient, baseUrl);
  }

  /**
   * @param orderId  
   * @return Success
   */
  deleteOrder(
    orderId: number,
    config?: any
  ): Observable<unknown> {
    let url = '/store/order/{orderId}?';
    url = url.replace('{orderId}', encodeURIComponent("" + orderId));

    return this.$delete(
      url,
      config
    );
  }

/**
   * @return Success
   */
  getInventory(
    config?: any
  ): Observable<{ [key: string]: number }> {
    let url = '/store/inventory?';

    return this.$get(
      url,
      config
    );
  }

/**
   * @param orderId  
   * @return Success
   */
  getOrderById(
    orderId: number,
    config?: any
  ): Observable<Order> {
    let url = '/store/order/{orderId}?';
    url = url.replace('{orderId}', encodeURIComponent("" + orderId));

    return this.$get(
      url,
      config
    );
  }

/**
   * @param body  
   * @return Success
   */
  placeOrder(
    body: Order,
    config?: any
  ): Observable<Order> {
    let url = '/store/order?';

    return this.$post(
      url,
      body,
      config
    );
  }

}

@Injectable({
  providedIn: 'root'
})
export class userService extends BaseService {
  constructor(
    @Inject(HttpClient) httpClient: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    super(httpClient, baseUrl);
  }

  /**
   * @param body  
   * @return Success
   */
  createUser(
    body: User,
    config?: any
  ): Observable<unknown> {
    let url = '/user?';

    return this.$post(
      url,
      body,
      config
    );
  }

/**
   * @param body  
   * @return Success
   */
  createUsersWithArrayInput(
    body: User[],
    config?: any
  ): Observable<unknown> {
    let url = '/user/createWithArray?';

    return this.$post(
      url,
      body,
      config
    );
  }

/**
   * @param body  
   * @return Success
   */
  createUsersWithListInput(
    body: User[],
    config?: any
  ): Observable<unknown> {
    let url = '/user/createWithList?';

    return this.$post(
      url,
      body,
      config
    );
  }

/**
   * @param username  
   * @return Success
   */
  deleteUser(
    username: string,
    config?: any
  ): Observable<unknown> {
    let url = '/user/{username}?';
    url = url.replace('{username}', encodeURIComponent("" + username));

    return this.$delete(
      url,
      config
    );
  }

/**
   * @param username  
   * @return Success
   */
  getUserByName(
    username: string,
    config?: any
  ): Observable<User> {
    let url = '/user/{username}?';
    url = url.replace('{username}', encodeURIComponent("" + username));

    return this.$get(
      url,
      config
    );
  }

/**
   * @param username  
   * @param password  
   * @return Success
   */
  loginUser(
    username: string,
    password: string,
    config?: any
  ): Observable<string> {
    let url = '/user/login?';
    if (username !== undefined) {
      url += 'username=' + encodeURIComponent("" + username) + "&";
    }
    if (password !== undefined) {
      url += 'password=' + encodeURIComponent("" + password) + "&";
    }
  
    return this.$get(
      url,
      config
    );
  }

/**
   * @return Success
   */
  logoutUser(
    config?: any
  ): Observable<unknown> {
    let url = '/user/logout?';

    return this.$get(
      url,
      config
    );
  }

/**
   * @param username  
   * @param body  
   * @return Success
   */
  updateUser(
    username: string,
    body: User,
    config?: any
  ): Observable<unknown> {
    let url = '/user/{username}?';
    url = url.replace('{username}', encodeURIComponent("" + username));

    return this.$put(
      url,
      body,
      config
    );
  }

}

export interface ApiResponse {
  code?: number;
  type?: string;
  message?: string;
}

export interface Category {
  id?: number;
  name?: string;
}

export interface Pet {
  name: string;
  photoUrls: string[];
  id?: number;
  category?: Category;
  tags?: Tag[];

  status?: 'available'|'pending'|'sold';
}

export interface Tag {
  id?: number;
  name?: string;
}

export interface Order {
  id?: number;
  petId?: number;
  quantity?: number;
  shipDate?: Date;

  status?: 'placed'|'approved'|'delivered';
  complete?: boolean;
}

export interface User {
  id?: number;
  username?: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  password?: string;
  phone?: string;

  userStatus?: number;
}
