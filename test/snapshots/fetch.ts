/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//   Generated using Swaggie (https://github.com/yhnavein/swaggie)
//   Please avoid doing any manual changes in this file
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
// deno-lint-ignore-file

export const defaults = {
  baseUrl: '',
  paramsSerializer: (params: any) => paramsSerializer(params),
};

export const petClient = {
    /**
   * @param body  
   */
  addPet(body: Pet ,
    $config?: RequestInit
  ): Promise<Pet> {
    const url = `${defaults.baseUrl}/pet?`;

    return fetch(url, {
      method: 'POST',
      body: JSON.stringify(body),
      ...$config,
    })
    .then((response) => response.json() as Promise<Pet>);
  },

  /**
   * @param apiKey (optional) (API name: api_key)
   * @param petId  
   */
  deletePet(apiKey: string | null | undefined,
    petId: number ,
    $config?: RequestInit
  ): Promise<unknown> {
    const url = `${defaults.baseUrl}/pet/${encodeURIComponent(`${petId}`)}?`;

    return fetch(url, {
      method: 'DELETE',
      headers: {
        'api_key': apiKey ?? '',
      },
      ...$config,
    })
    .then((response) => response.json() as Promise<unknown>);
  },

  /**
   * @param status (optional) 
   */
  findPetsByStatus(status: ("available" | "pending" | "sold") | null | undefined,
    $config?: RequestInit
  ): Promise<Pet[]> {
    const url = `${defaults.baseUrl}/pet/findByStatus?${defaults.paramsSerializer({'status': status,
      })}`;

    return fetch(url, {
      method: 'GET',
      ...$config,
    })
    .then((response) => response.json() as Promise<Pet[]>);
  },

  /**
   * @param tags (optional) 
   */
  findPetsByTags(tags: string[] | null | undefined,
    $config?: RequestInit
  ): Promise<Pet[]> {
    const url = `${defaults.baseUrl}/pet/findByTags?${defaults.paramsSerializer({'tags': tags,
      })}`;

    return fetch(url, {
      method: 'GET',
      ...$config,
    })
    .then((response) => response.json() as Promise<Pet[]>);
  },

  /**
   * @param petId  
   */
  getPetById(petId: number ,
    $config?: RequestInit
  ): Promise<Pet> {
    const url = `${defaults.baseUrl}/pet/${encodeURIComponent(`${petId}`)}?`;

    return fetch(url, {
      method: 'GET',
      ...$config,
    })
    .then((response) => response.json() as Promise<Pet>);
  },

  /**
   * @param body  
   */
  updatePet(body: Pet ,
    $config?: RequestInit
  ): Promise<Pet> {
    const url = `${defaults.baseUrl}/pet?`;

    return fetch(url, {
      method: 'PUT',
      body: new URLSearchParams(body as any),
      ...$config,
    })
    .then((response) => response.json() as Promise<Pet>);
  },

  /**
   * @param petId  
   * @param name (optional) 
   * @param status (optional) 
   */
  updatePetWithForm(petId: number ,
    name: string | null | undefined,
    status: string | null | undefined,
    $config?: RequestInit
  ): Promise<unknown> {
    const url = `${defaults.baseUrl}/pet/${encodeURIComponent(`${petId}`)}?${defaults.paramsSerializer({'name': name,
      'status': status,
      })}`;

    return fetch(url, {
      method: 'POST',
      ...$config,
    })
    .then((response) => response.json() as Promise<unknown>);
  },

  /**
   * @param body (optional) 
   * @param petId  
   * @param additionalMetadata (optional) 
   */
  uploadFile(body: File | null | undefined,
    petId: number ,
    additionalMetadata: string | null | undefined,
    $config?: RequestInit
  ): Promise<File> {
    const url = `${defaults.baseUrl}/pet/${encodeURIComponent(`${petId}`)}/uploadImage?${defaults.paramsSerializer({'additionalMetadata': additionalMetadata,
      })}`;

    return fetch(url, {
      method: 'POST',
      body: body,
      ...$config,
    })
    .then((response) => response.blob() as Promise<File>);
  },

};
export const storeClient = {
    /**
   * @param orderId  
   */
  deleteOrder(orderId: number ,
    $config?: RequestInit
  ): Promise<unknown> {
    const url = `${defaults.baseUrl}/store/order/${encodeURIComponent(`${orderId}`)}?`;

    return fetch(url, {
      method: 'DELETE',
      ...$config,
    })
    .then((response) => response.json() as Promise<unknown>);
  },

  /**
   */
  getInventory($config?: RequestInit
  ): Promise<{ [key: string]: number }> {
    const url = `${defaults.baseUrl}/store/inventory?`;

    return fetch(url, {
      method: 'GET',
      ...$config,
    })
    .then((response) => response.json() as Promise<{ [key: string]: number }>);
  },

  /**
   * @param orderId  
   */
  getOrderById(orderId: number ,
    $config?: RequestInit
  ): Promise<Order> {
    const url = `${defaults.baseUrl}/store/order/${encodeURIComponent(`${orderId}`)}?`;

    return fetch(url, {
      method: 'GET',
      ...$config,
    })
    .then((response) => response.json() as Promise<Order>);
  },

  /**
   * @param body (optional) 
   */
  placeOrder(body: Order | null | undefined,
    $config?: RequestInit
  ): Promise<Order> {
    const url = `${defaults.baseUrl}/store/order?`;

    return fetch(url, {
      method: 'POST',
      body: JSON.stringify(body),
      ...$config,
    })
    .then((response) => response.json() as Promise<Order>);
  },

};
export const userClient = {
    /**
   * @param body (optional) 
   */
  createUser(body: User | null | undefined,
    $config?: RequestInit
  ): Promise<User> {
    const url = `${defaults.baseUrl}/user?`;

    return fetch(url, {
      method: 'POST',
      body: JSON.stringify(body),
      ...$config,
    })
    .then((response) => response.json() as Promise<User>);
  },

  /**
   * @param body (optional) 
   */
  createUsersWithListInput(body: User[] | null | undefined,
    $config?: RequestInit
  ): Promise<User> {
    const url = `${defaults.baseUrl}/user/createWithList?`;

    return fetch(url, {
      method: 'POST',
      body: JSON.stringify(body),
      ...$config,
    })
    .then((response) => response.json() as Promise<User>);
  },

  /**
   * @param username  
   */
  deleteUser(username: string ,
    $config?: RequestInit
  ): Promise<unknown> {
    const url = `${defaults.baseUrl}/user/${encodeURIComponent(`${username}`)}?`;

    return fetch(url, {
      method: 'DELETE',
      ...$config,
    })
    .then((response) => response.json() as Promise<unknown>);
  },

  /**
   * @param username  
   */
  getUserByName(username: string ,
    $config?: RequestInit
  ): Promise<User> {
    const url = `${defaults.baseUrl}/user/${encodeURIComponent(`${username}`)}?`;

    return fetch(url, {
      method: 'GET',
      ...$config,
    })
    .then((response) => response.json() as Promise<User>);
  },

  /**
   * @param username (optional) 
   * @param password (optional) 
   */
  loginUser(username: string | null | undefined,
    password: string | null | undefined,
    $config?: RequestInit
  ): Promise<string> {
    const url = `${defaults.baseUrl}/user/login?${defaults.paramsSerializer({'username': username,
      'password': password,
      })}`;

    return fetch(url, {
      method: 'GET',
      ...$config,
    })
    .then((response) => response.json() as Promise<string>);
  },

  /**
   */
  logoutUser($config?: RequestInit
  ): Promise<unknown> {
    const url = `${defaults.baseUrl}/user/logout?`;

    return fetch(url, {
      method: 'GET',
      ...$config,
    })
    .then((response) => response.json() as Promise<unknown>);
  },

  /**
   * @param body (optional) 
   * @param username  
   */
  updateUser(body: FormData | null | undefined,
    username: string ,
    $config?: RequestInit
  ): Promise<unknown> {
    const url = `${defaults.baseUrl}/user/${encodeURIComponent(`${username}`)}?`;

    return fetch(url, {
      method: 'PUT',
      body: JSON.stringify(body),
      ...$config,
    })
    .then((response) => response.json() as Promise<unknown>);
  },

};

function paramsSerializer<T = any>(params: T, parentKey: string | null = null): string {
  if (params === undefined || params === null) return '';
  const encodedParams: string[] = [];
  const encodeValue = (value: any) =>
    encodeURIComponent(value instanceof Date && !Number.isNaN(value) ? value.toISOString() : value);

  for (const key in params) {
    if (Object.prototype.hasOwnProperty.call(params, key)) {
      const value = (params as any)[key];
      if (value !== undefined) {
        const fullKey = parentKey ? `${parentKey}.${key}` : key;

        if (Array.isArray(value)) {
          for (const element of value) {
            encodedParams.push(`${encodeURIComponent(fullKey)}=${encodeValue(element)}`);
          }
        } else if (value instanceof Date && !Number.isNaN(value)) {
          // If the value is a Date, convert it to ISO format
          encodedParams.push(`${encodeURIComponent(fullKey)}=${encodeValue(value)}`);
        } else if (typeof value === 'object') {
          // If the value is an object or array, recursively encode its contents
          const result = paramsSerializer(value, fullKey);
          if (result !== '') encodedParams.push(result);
        } else {
          // Otherwise, encode the key-value pair
          encodedParams.push(`${encodeURIComponent(fullKey)}=${encodeValue(value)}`);
        }
      }
    }
  }

  return encodedParams.join('&');
}

export interface Order {
  id?: number;
  petId?: number;
  quantity?: number;
  shipDate?: Date;
// Order Status
  status?: ("placed" | "approved" | "delivered");
  complete?: boolean;}

export interface Customer {
  id?: number;
  username?: string;
  address?: Address[];}

export interface Address {
  street?: string;
  city?: string;
  state?: string;
  zip?: string;}

export interface Category {
  id?: number;
  name?: string;}

export interface User {
  id?: number;
  username?: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  password?: string;
  phone?: string;
// User Status
  userStatus?: number;}

export interface Tag {
  id?: number;
  name?: string;}

export interface Pet {
  id?: number;
  name: string;
  category?: Category;
  photoUrls: string[];
  tags?: Tag[];
// pet status in the store
  status?: ("available" | "pending" | "sold");}

export interface ApiResponse {
  code?: number;
  type?: string;
  message?: string;}
